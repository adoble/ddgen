# Test defintion for the si486x radio
# Covers a limited number of commands
#  Implication from the data sheet is that CS (SSB) is held low for the 
# send duration of the command and all args. 
# CS is also held low for the duration of all bytes in the response
# 

# TODO ABNF description of this (see https://github.com/toml-lang/toml/blob/1.0.0/toml.abnf) 
version = "0.0.2"

[device]
name      = "si468x"
endian    = "le"
word_size = 8

[struct.header]
cts     = { bits = "7" }
err_cmd = { bits = "6" }
dacqint = { bits = "5", description = "Digital radio link change interrupt indicator." }
dsrvint = { bits = "4", description = "An enabled data component of one of the digital services requires attention." }
stcint  = { bits = "0", description = "Seek / tune complete" }

devntint = { bits = "1[5]", description = "Digital radio event change interrupt indicator." }

pup_state        = { bits = "3[6..7]", type = "power_up_state" }
dsp_err          = { bits = "3[4]", description = "The DSP has encountered a frame overrun." }
repo_fatal_error = { bits = "3[3]" }
cmdo_fatal_error = { bits = "3[2]" }
arb_error        = { bits = "3[1]" }
error_nr         = { bits = "3[0]" }
# rsvd_stat: Reserved for future use 


[commands.GET_SYS_STATE]
opcode       = 0x09
flow_control = { type = "polled", on = "header", condition = "cts" }


# The sizes of the requests and the reponses are soley determined for the fields and their bit specifications
# This can be derived from max "word" value
description = """GET_SYS_STATE reports basic system state information such as which mode is active; FM, DAB, etc. The
command is complete when the CTS bit (and optional interrupt) is set. The ERR bit (and optional interrupt) is set if
an invalid argument is sent. Note that only a single interrupt occurs if both the CTS and ERR bits are set. The
command may only be sent in powerup mode. Note: GET_SYS_STATE command is not supported in firmware
revision A0A."""

[commands.GET_SYS_STATE.request] ## or parameters
arg1 = { bits = "1[0x00]" }

[commands.GET_SYS_STATE.response]
header = { bits = "0[]..3[]", struct = "header" }
image  = { bits = "4[0..7]", type = "active_processing_image" }
dummy  = { bits = "5[]" }

[enum.active_processing_image]
bootloader            = 0
fmhd                  = 1
dab                   = 2
tdmb_or_data_only_dab = 3
fmhd_demod            = 4
amhd                  = 5
amhd_demod            = 6
dab_demod             = 7

[enum.power_up_state]
reset              = 0
bootloader_running = 2
app_running        = 3
# variant 1 is reserved

[commands.DAB_TUNE_FREQ]
opcode = 0xB0
flow_control = { type = "polled", on = "header", condition = "cts" }
description = """DAB_TUNE_FREQ sets the DAB Receiver to tune to a frequency between 168.16 MHz and 239.20 MHz defined
by the table through DAB_SET_FREQ_LIST."""

[commands.DAB_TUNE_FREQ.request]
injection           = { bits = "0[0..1]", type = "injection" }
freq_index          = { bits = "1[]" }                         # Uses all 8 bits
antenna_capacitance = { bits = "3[]..4[]" }                    # 16 bit value range 0-128. Bits not specified so use whole word

[commands.DAB_TUNE_FREQ.response]
header = { bits = "0[]..3[]", struct = "header" }


[enum.injection]
automatic = 0
low_side  = 1
high_side = 2

[commands.DAB_SET_FREQ_LIST]
opcode = 0xB8
flow_control = { type = "polled", on = "header", condition = "cts" }
description = """DAB_SET_FREQ_LIST command sets the DAB frequency table. The frequencies are in units of 1 kHz. The table
can be populated with a single entry or a regional list (for example 5 or 6 entries]. It is recommended to make the
list regional to increase scanning speed. The command is complete when the CTS bit (and optional interrupt) is
set. The ERR bit (and optional interrupt) is set if an invalid argument is sent. Note that only a single interrupt occurs
if both the CTS and ERR bits are set. The command may only be sent in powerup mode"""

[commands.DAB_SET_FREQ_LIST.request]
number_frequencies = { bits = "0[]" }
frequencies        = { bits = "3[]..4[];(0[])<=48", type = "u16" }


[commands.DAB_SET_FREQ_LIST.response]
header = { bits = "0[]..3[]", struct = "header" }

[commands.POWER_UP]
opcode       = 0x01
flow_control = { type = "polled", on = "header", condition = "cts" }
description  = """The POWER_UP initiates the boot process to move the device from power down to power up mode. """

[commands.POWER_UP.request]
ibias_run      = { bits = "12[0..6]", description = "TAL IBIAS current at runtime, after the XTAL oscillator has stabilized" }
cts_is_enabled = { bits = "0[7]", description = "The bootloader will toggle a host interrupt line when CTS is available." }
clock_mode     = { bits = "1[4..5]", type = "clock_mode" }
tr_size        = { bits = "1[0..3]", type = "u8", description = "Range 1-15" }
ibais          = { bits = "2[0..6]", type = "u8", description = "XTAL IBIAS current at startup. Range 0-127" }
xtal_frequency = { bits = "3[]..6[]", type = "u32", description = "XTAL frequency in Hz" }
ctun           = { bits = "7[0..5]", type = "u8", description = "Range 0-63" }
arg9           = { bits = "8[0b00010000]" }

[commands.POWER_UP.response]
header = { bits = "0[]..3[]", struct = "header" }

[enum.clock_mode]
powered_down                       = 0
xtal_mode                          = 1
oscillator_off_single_ended_buffer = 2
oscillator_off_differential_buffer = 3


[commands.HOST_LOAD]
opcode       = 0x04
flow_control = { type = "polled", on = "header", condition = "cts" }
description  = "HOST_LOAD loads an image from HOST over command interface"

[commands.HOST_LOAD.request]
arg1       = { bits = "0[0x00]" }
arg2       = { bits = "1[0x00]" }
arg3       = { bits = "2[0x00]" }
image_data = { bits = "3[];<=4096", type = "HostImageDataLoader" } # This is actually variable repeat with NO count word

[commands.HOST_LOAD.response]
header = { bits = "0[];4", struct = "header" } # Trying out a different bit lang expression here to see if it still works. 

[commands.FLASH_LOAD]
opcode       = 0x05
flow_control = { type = "polled", on = "header", condition = "cts" }
description  = "FLASH_LOAD loads the firmware image from an externally attached SPI flash over the secondary SPI bus."

[commands.FLASH_LOAD.request]
arg1                = { bits = "0[0x00]" }
arg2                = { bits = "1[0x00]" }
arg3                = { bits = "2[0x00]" }
flash_start_address = { bits = "3[]..6[]", description = "Flash byte starting address of image to load" }
arg8                = { bits = "7[0x00]" }
arg9                = { bits = "8[0x00]" }
arg10               = { bits = "9[0x00]" }
arg11               = { bits = "10[0x00]" }

[commands.FLASH_LOAD.response]
header = { bits = "0[]..3[]", struct = "header" }

[commands.LOAD_INIT]
opcode       = 0x06
flow_control = { type = "polled", on = "header", condition = "cts" }
description  = "LOAD_INIT prepares the bootloader to receive a new image."

[commands.LOAD_INIT.request]
arg1 = { bits = "0[0x00]" }

[commands.LOAD_INIT.response]
header = { bits = "0[];4", struct = "header" }


[commands.BOOT]
opcode       = 0x07
flow_control = { type = "polled", on = "header", condition = "cts" }
description  = "LOAD_INIT prepares the bootloader to receive a new image."

[commands.BOOT.request]
arg1 = { bits = "0[0x00]" }

[commands.BOOT.response]
header = { bits = "0[];4", struct = "header" }

[commands.GET_PART_INFO]
opcode       = 0x08
flow_control = { type = "polled", on = "header", condition = "cts" }
description  = "GET_PART_INFO reports basic information about the device such as Part Number, Part Version, ROM ID, etc.."

[commands.GET_PART_INFO.request]
arg1 = { bits = "0[0x00]" }

[commands.GET_PART_INFO.response]
header             = { bits = "0[];4", struct = "header" }
chip_mask_revision = { bits = "4[]" }
rom_id             = { bits = "5[]" }
part_number        = { bits = "8[]..9[]" }
_padding           = { bits = "10[];13" }

[commands.GET_FUNC_INFO]
opcode = 0x12
flow_control = { type = "polled", on = "header", condition = "cts" }
description = """GET_FUNC_INFO returns the function revision number for currently loaded firmware (FMHD, AM etc.) as opposed
to GET_PART_INFO command that provides the revision number for the combo firmware. For example,
GET_PART_INFO would return A0B is the firmware revision while GET_FUNC_INFO would return 1.0.4 for FM
function revision if the currently running firmware function is FM."""

[commands.GET_FUNC_INFO.request]
arg1 = { bits = "0[0x00]" }

[commands.GET_FUNC_INFO.response]
header                = { bits = "0[];4", struct = "header" }
major_revision_number = { bits = "4[]", description = "First part of 1.2.3" }
minor_revision_number = { bits = "5[]", description = "Second part of 1.2.3" }
build_revision_number = { bits = "6[]", description = "Third part of 1.2.3" }
no_svn                = { bits = "7[7]", description = "If set the build was created with no SVN info." }
location              = { bits = "7[4..5]", type = "image_build_location", description = "The location from which the image was built." }
mixed_revisions       = { bits = "7[1]", description = "If set, the image was built from mixed revisions." }
local_modifications   = { bits = "7[0]", description = "If set, the image has local modifications." }
svn_id                = { bits = "8[]..11[]", description = "SVN ID for which the image was built." }


[enum.image_build_location]
tag    = 0
branch = 1
trunk  = 2


[commands.SET_PROPERTY]
opcode       = 0x13
flow_control = { type = "polled", on = "header", condition = "cts" }
description  = """SET_PROPERTY sets the value of a property"""

[commands.SET_PROPERTY.request]
arg1        = { bits = "0[0x00]" }
property_id = { bits = "1[]..2[]", description = "ID of the property to set." }
data        = { bits = "3[]..4[]", type = "i16", description = "Value for the written property." }

[commands.SET_PROPERTY.response]
header = { bits = "0[];4", struct = "header" }


[commands.DAB_GET_DIGITAL_SERVICE_LIST]
opcode       = 0x80
flow_control = { type = "polled", on = "header", condition = "cts" }
description  = """GET_DIGITAL_SERVICE_LIST gets a service list of the ensemble."""

[commands.DAB_GET_DIGITAL_SERVICE_LIST.request]
service_type = { bits = "0[0..1]", type = "service_type", description = "Sets the type of service list to retrieve." }

[commands.DAB_GET_DIGITAL_SERVICE_LIST.response]
header       = { bits = "0[];4", struct = "header" }
service_size = { bits = "4[]..5[]", description = "The size of the service list in bytes." }
data         = { bits = "6[]..7[];(4[]..5[])<=2047", description = "A max of 2047 bytes of service information" }


[enum.service_type]
audio_service = 0
data_service  = 1
hd_audio_info = 2
hd_data_info  = 3


[commands.START_DIGITAL_SERVICE]
opcode = 0x81
flow_control = { type = "polled", on = "header", condition = "cts" }
description = """START_DIGITAL_SERVICE starts an audio or data service. This command is used for HD audio and data
services."""

[commands.START_DIGITAL_SERVICE.request]
service_type = { bits = "0[0..0]", type = "service_selector", description = "Sets the type of service to start for HD applications." }
arg2         = { bits = "1[0x00]" }
arg3         = { bits = "2[0x00]" }
service_id   = { bits = "3[]..6[]", description = "The service's Service Number (HD)." }
comp_id      = { bits = "7[]..10[]", description = "The service's Port/Program Number (HD)" }

[commands.START_DIGITAL_SERVICE.response]
header = { bits = "0[];4", struct = "header" }

[enum.service_selector]
audio = 0
data  = 1

#-------------
[commands.STOP_DIGITAL_SERVICE]
opcode       = 0x82
flow_control = { type = "polled", on = "header", condition = "cts" }
description  = """START_DIGITAL_SERVICE stops an audio or data service."""

[commands.STOP_DIGITAL_SERVICE.request]
service_type = { bits = "0[0..0]", type = "service_selector", description = "Sets the type of service to start for HD applications." }
arg2         = { bits = "1[0x00]" }
arg3         = { bits = "2[0x00]" }
service_id   = { bits = "3[]..6[]", description = "The service's Service Number (HD)." }
comp_id      = { bits = "7[]..10[]", description = "The service's Port/Program Number (HD)" }

[commands.STOP_DIGITAL_SERVICE.response]
header = { bits = "0[];4", struct = "header" }

# Commands used in the DABShield C++ driver
# POWER_UP       X
# HOST_LOAD      X
# FLASH_LOAD     X
# LOAD_INIT      X
# BOOT           X
# GET_PART_INFO  X
# GET_FUNC_INFO  X
# SET_PROPERTY   X
# DAB_GET_DIGITAL_SERVICE_LIST X
# DAB_START_DIGITAL_SERVICE
# GET_DIGITAL_SERVICE_DATA
# DAB_TUNE_FREQ
# DAB_DIGRAD_STATUS
# DAB_GET_EVENT_STATUS
# DAB_GET_ENSEMBLE_INFO
# DAB_SET_FREQ_LIST
# DAB_GET_ENSEMBLE_INFO
# GET_TIME
# DAB_GET_AUDIO_INFO
# DAB_GET_SUBCHAN_INFO
# DAB_GET_SERVICE_INFO
# READ_OFFSET
# FM_TUNE_FREQ
# FM_SEEK_START
# FM_RSQ_STATUS
# FM_RDS_STATUS
