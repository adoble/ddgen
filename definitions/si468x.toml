# Test defintion for the si486x radio
# Covers a limited number of commands
#  Implication from the data sheet is that CS (SSB) is held low for the 
# send duration of the command and all args. 
# CS is also held low for the duration of all bytes in the response
# 

# TODO ABNF description of this (see https://github.com/toml-lang/toml/blob/1.0.0/toml.abnf) 
version = "0.0.2"

[device]
name      = "si468x"
endian    = "le"
word_size = 8

[struct.header]
cts     = { bits = "7" }
err_cmd = { bits = "6" }
dacqint = { bits = "5", description = "Digital radio link change interrupt indicator." }
dsrvint = { bits = "4", description = "An enabled data component of one of the digital services requires attention." }
stcint  = { bits = "0", description = "Seek / tune complete" }

devntint = { bits = "1[5]", description = "Digital radio event change interrupt indicator." }

pup_state        = { bits = "3[6..7]", type = "power_up_state" }
dsp_err          = { bits = "3[4]", description = "The DSP has encountered a frame overrun." }
repo_fatal_error = { bits = "3[3]" }
cmdo_fatal_error = { bits = "3[2]" }
arb_error        = { bits = "3[1]" }
error_nr         = { bits = "3[0]" }
# rsvd_stat: Reserved for future use 


[commands.GET_SYS_STATE]
opcode = 0x09
# The sizes of the requests and the reponses are soley determined for the fields and their bit specifications
# This can be derived from max "word" value
description = """GET_SYS_STATE reports basic system state information such as which mode is active; FM, DAB, etc. The
command is complete when the CTS bit (and optional interrupt) is set. The ERR bit (and optional interrupt) is set if
an invalid argument is sent. Note that only a single interrupt occurs if both the CTS and ERR bits are set. The
command may only be sent in powerup mode. Note: GET_SYS_STATE command is not supported in firmware
revision A0A."""

[commands.GET_SYS_STATE.request] ## or parameters
arg1 = { bits = "1[0x00]" }

[commands.GET_SYS_STATE.response]
header = { bits = "0[]..3[]", struct = "header" }
image  = { bits = "4[0..7]", type = "active_processing_image" }
dummy  = { bits = "5[]" }

[enum.active_processing_image]
bootloader            = 0
fmhd                  = 1
dab                   = 2
tdmb_or_data_only_dab = 3
fmhd_demod            = 4
amhd                  = 5
amhd_demod            = 6
dab_demod             = 7

[enum.power_up_state]
reset              = 0
bootloader_running = 2
app_running        = 3
# variant 1 is reserved

[commands.DAB_TUNE_FREQ]
opcode = 0xB0
description = """DAB_TUNE_FREQ sets the DAB Receiver to tune to a frequency between 168.16 MHz and 239.20 MHz defined
by the table through DAB_SET_FREQ_LIST."""

[commands.DAB_TUNE_FREQ.request]
injection           = { bits = "0[0..1]", type = "injection" }
freq_index          = { bits = "1[]" }                         # Uses all 8 bits
antenna_capacitance = { bits = "3[]..4[]" }                    # 16 bit value range 0-128. Bits not specified so use whole word

[commands.DAB_TUNE_FREQ.response]
header = { bits = "0[]..3[]", struct = "header" }


[enum.injection]
automatic = 0
low_side  = 1
high_side = 2

[commands.DAB_SET_FREQ_LIST]
opcode = 0xB8
description = """DAB_SET_FREQ_LIST command sets the DAB frequency table. The frequencies are in units of 1 kHz. The table
can be populated with a single entry or a regional list (for example 5 or 6 entries]. It is recommended to make the
list regional to increase scanning speed. The command is complete when the CTS bit (and optional interrupt) is
set. The ERR bit (and optional interrupt) is set if an invalid argument is sent. Note that only a single interrupt occurs
if both the CTS and ERR bits are set. The command may only be sent in powerup mode"""

[commands.DAB_SET_FREQ_LIST.request]
number_frequencies = { bits = "0[]" }
frequencies        = { bits = "3[]..4[];(0[])<=48", type = "u16" }


[commands.DAB_SET_FREQ_LIST.response]
header = { bits = "0[]..3[]", struct = "header" }

[commands.POWER_UP]
opcode      = 0x01
description = """The POWER_UP initiates the boot process to move the device from power down to power up mode. """

[commands.POWER_UP.request]
ibias_run      = { bits = "12[0..6]", description = "TAL IBIAS current at runtime, after the XTAL oscillator has stabilized" }
cts_is_enabled = { bits = "0[7]", description = "The bootloader will toggle a host interrupt line when CTS is available." }
clock_mode     = { bits = "1[4..5]", type = "clock_mode" }
tr_size        = { bits = "1[0..3]", type = "u8", description = "Range 1-15" }
ibais          = { bits = "2[0..6]", type = "u8", description = "XTAL IBIAS current at startup. Range 0-127" }
xtal_frequency = { bits = "3[]..6[]", type = "u32", description = "XTAL frequency in Hz" }
ctun           = { bits = "7[0..5]", type = "u8", description = "Range 0-63" }
arg9           = { bits = "8[0b00010000]" }

[commands.POWER_UP.response]
header = { bits = "0[]..3[]", struct = "header" }

[enum.clock_mode]
powered_down                       = 0
xtal_mode                          = 1
oscillator_off_single_ended_buffer = 2
oscillator_off_differential_buffer = 3


[commands.HOST_LOAD]
opcode      = 0x04
description = "HOST_LOAD loads an image from HOST over command interface"

[commands.HOST_LOAD.request]
arg1       = { bits = "0[0x00]" }
arg2       = { bits = "1[0x00]" }
arg3       = { bits = "2[0x00]" }
image_data = { bits = "3[];<=4096", type = "HostLoader" } # This is actually variable repeat with NO count word

[commands.HOST_LOAD.response]
header = { bits = "0[];4", struct = "header" } # Trying out a different bit lang expression here to see if it still works. 

[commands.FLASH_LOAD]
opcode      = 0x05
description = "FLASH_LOAD loads the firmware image from an externally attached SPI flash over the secondary SPI bus."

[commands.FLASH_LOAD.request]
arg1                = { bits = "0[0x00]" }
arg2                = { bits = "1[0x00]" }
arg3                = { bits = "2[0x00]" }
flash_start_address = { bits = "3[]..6[]", description = "Flash byte starting address of image to load" }
arg8                = { bits = "7[0x00]" }
arg9                = { bits = "8[0x00]" }
arg10               = { bits = "9[0x00]" }
arg11               = { bits = "10[0x00]" }

[commands.FLASH_LOAD.response]
header = { bits = "0[]..3[]", struct = "header" }

# Commands used in the DABShield C++ driver
# POWER_UP       X
# HOST_LOAD      X
# FLASH_LOAD
# LOAD_INIT
# BOOT
# GET_PART_INFO
# READ_OFFSET
# GET_FUNC_INFO
# SET_PROPERTY
# FM_TUNE_FREQ
# FM_SEEK_START
# FM_RSQ_STATUS
# FM_RDS_STATUS
# DAB_GET_DIGITAL_SERVICE_LIST
# DAB_START_DIGITAL_SERVICE
# GET_DIGITAL_SERVICE_DATA
# DAB_TUNE_FREQ
# DAB_DIGRAD_STATUS
# DAB_GET_EVENT_STATUS
# DAB_GET_ENSEMBLE_INFO
# DAB_SET_FREQ_LIST
# DAB_GET_ENSEMBLE_INFO
# GET_TIME
# DAB_GET_AUDIO_INFO
# DAB_GET_SUBCHAN_INFO
# DAB_GET_SERVICE_INFO
